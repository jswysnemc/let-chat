<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多模态 AI 交互示例 (代码块增强)</title>
    <!-- Highlight.js CSS (例如：GitHub 主题) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            background-color: #e5ddd5; /* 类似聊天应用的背景色 */
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: 100vh; /* 使 body 占满视口高度 */
            box-sizing: border-box;
        }
        h1, h2 {
            color: #333;
            text-align: center;
            margin-bottom: 15px;
            flex-shrink: 0; /* 防止标题被压缩 */
        }
        .section {
            background-color: #f4f4f4; /* 内部区域背景 */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        #chat-container {
             flex-grow: 1; /* 让聊天容器占据剩余空间 */
             overflow: hidden; /* 防止内容溢出 */
             background-color: transparent; /* 聊天容器透明，使用 body 背景 */
             padding: 10px; /* 减少内边距 */
             box-shadow: none; /* 移除阴影 */
        }
        #chat-container h2 {
            margin-bottom: 10px;
        }
        #ai-response {
            border: none; /* 移除边框 */
            background-color: transparent; /* 透明背景 */
            padding: 10px 0; /* 调整内边距 */
            flex-grow: 1; /* 占据聊天容器剩余空间 */
            overflow-y: auto; /* 内部滚动 */
            margin-bottom: 15px;
            border-radius: 0; /* 移除圆角 */
            display: flex; /* 使用 Flexbox 排列气泡 */
            flex-direction: column; /* 垂直排列 */
            gap: 10px; /* 气泡之间的间隙 */
        }

        /* --- 聊天气泡样式 --- */
        .message-bubble {
            padding: 10px 15px;
            border-radius: 18px; /* 更圆的边角 */
            max-width: 75%; /* 气泡最大宽度 */
            word-wrap: break-word; /* 允许长单词换行 */
            position: relative; /* 用于复制按钮定位 */
            box-shadow: 0 1px 1px rgba(0,0,0,0.1); /* 轻微阴影 */
            line-height: 1.5; /* 调整行高 */
        }
        .user-bubble {
            background-color: #dcf8c6; /* 用户的浅绿色气泡 */
            align-self: flex-end; /* 用户靠右 */
            border-bottom-right-radius: 5px; /* 右下角略方 */
            margin-left: auto; /* 确保靠右 */
        }
        .assistant-bubble {
            background-color: #ffffff; /* 助手的白色气泡 */
            align-self: flex-start; /* 助手靠左 */
            border: 1px solid #eee;
            border-bottom-left-radius: 5px; /* 左下角略方 */
            margin-right: auto; /* 确保靠左 */
            padding-right: 40px; /* 为消息复制按钮留出空间 */
        }
        .message-bubble strong { /* 发送者前缀 */
            display: block;
            margin-bottom: 4px;
            font-size: 0.85em;
            font-weight: bold;
            color: #555;
        }
        .user-bubble strong {
            color: #075e54; /* 用户前缀颜色 */
        }
        .assistant-bubble strong {
             color: #4a4a4a; /* 助手前缀颜色 */
        }
        .user-bubble .user-message-content img { /* 用户发送的图片 */
             max-width: 100px;
             max-height: 100px;
             vertical-align: middle;
             margin: 5px 5px 5px 0;
             border: 1px solid #ddd;
             border-radius: 4px;
             display: inline-block; /* 让图片和文本能在同一行 */
        }
        .assistant-bubble .assistant-message-content { /* 助手消息内容容器 */
            white-space: normal; /* 允许 Markdown 换行 */
        }
        .assistant-bubble .assistant-message-content p:last-child {
             margin-bottom: 0; /* 移除气泡内最后一个段落的下边距 */
        }
        /* Markdown 基础样式 (在气泡内) */
        .assistant-message-content p { margin-top: 0; margin-bottom: 0.8em; }
        .assistant-message-content ul, .assistant-message-content ol { padding-left: 1.5em; margin-bottom: 0.8em; }
        .assistant-message-content li { margin-bottom: 0.4em; }
        .assistant-message-content blockquote { margin-left: 0.5em; padding-left: 0.8em; border-left: 3px solid #ccc; color: #666; margin-bottom: 0.8em; }
        .assistant-message-content pre {
            background-color: #f5f5f5;
            padding: 0.8em;
            padding-top: 2.2em; /* 增加顶部内边距为标签留空间 */
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 0.8em;
            position:relative; /* 相对定位，用于内部绝对定位 */
         }
        .assistant-message-content code { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.9em; }
        .assistant-message-content pre code { display: block; padding: 0; background: none; color: inherit; }

        /* 消息复制按钮样式 */
        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            color: #555;
            padding: 2px 6px;
            font-size: 0.75em;
            border-radius: 4px;
            cursor: pointer;
            opacity: 0; /* 默认隐藏 */
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 10; /* 确保在内容之上 */
        }
        .assistant-bubble:hover .copy-button {
            opacity: 0.7; /* 悬停时显示 */
        }
        .copy-button:hover {
            background-color: #e0e0e0;
            opacity: 1;
        }
        .copy-button:active {
            background-color: #d0d0d0;
        }

        /* 代码块语言标签样式 */
        .code-language-label {
            position: absolute;
            top: 0;
            left: 0; /* 改为左上角 */
            font-size: 0.8em;
            color: #888;
            background-color: #e0e0e0; /* 标签背景 */
            padding: 2px 6px;
            border-bottom-right-radius: 4px; /* 右下角圆角 */
            z-index: 5; /* 在代码复制按钮之下 */
            text-transform: lowercase;
        }

        /* 代码块复制按钮样式 */
        .code-copy-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #e0e0e0; /* 稍有区别 */
            border: 1px solid #bbb;
            color: #333;
            padding: 2px 6px;
            font-size: 0.75em;
            border-radius: 4px;
            cursor: pointer;
            opacity: 0; /* 默认隐藏 */
            transition: opacity 0.2s, background-color 0.2s;
            z-index: 10;
        }
        .assistant-message-content pre:hover .code-copy-button {
            opacity: 0.8; /* 在 pre 悬停时显示 */
        }
        .code-copy-button:hover {
            background-color: #d0d0d0;
            opacity: 1;
        }
        .code-copy-button:active {
            background-color: #c0c0c0;
        }
        /* --- 结束聊天气泡样式 --- */


        #chat-input-container {
            border: 1px solid #ccc;
            border-radius: 25px; /* 更圆的输入框容器 */
            padding: 0;
            background-color: #fff;
            display: flex; /* 使用 Flexbox 排列内部元素 */
            flex-direction: column; /* 垂直排列 */
            flex-shrink: 0; /* 防止输入区域被压缩 */
        }
        #chat-input { /* contenteditable div */
            min-height: 50px; /* 减少最小高度 */
            max-height: 150px; /* 限制最大高度 */
            padding: 12px 15px; /* 调整内边距 */
            box-sizing: border-box;
            width: 100%;
            font-size: 16px;
            line-height: 1.5;
            border: none;
            outline: none;
            resize: none; /* 禁止调整大小 */
            overflow-y: auto;
            background: transparent; /* 透明背景 */
        }
        #chat-input img { /* 输入区域内图片的样式 */
            max-width: 60px; /* 缩小图片 */
            max-height: 60px;
            vertical-align: middle;
            margin: 2px;
            border: 1px solid #eee;
            border-radius: 3px;
        }
        #input-image-preview { /* 输入下方用于预览的区域 */
            padding: 8px 15px; /* 调整内边距 */
            min-height: 40px;
            background-color: #f8f8f8;
            border-top: 1px dashed #ddd;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-items: center;
            border-bottom-left-radius: 25px; /* 匹配容器圆角 */
            border-bottom-right-radius: 25px;
        }
        #input-image-preview img { /* 预览区域图片的样式 */
            max-width: 40px; /* 缩小预览图 */
            max-height: 40px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        #input-controls { /* 包裹按钮和加载指示 */
             display: flex;
             justify-content: flex-end; /* 按钮靠右 */
             align-items: center;
             padding: 0 10px 10px 10px; /* 按钮区域的内边距 */
             flex-shrink: 0;
        }
        #send-button {
            padding: 8px 18px; /* 调整按钮大小 */
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 20px; /* 圆角按钮 */
            cursor: pointer;
            font-size: 15px;
            transition: background-color 0.2s ease;
            margin-top: 0; /* 移除上边距 */
            margin-left: 10px; /* 与加载指示的间距 */
        }
        #send-button:hover {
            background-color: #0056b3;
        }
        #send-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .placeholder-text {
            color: #aaa;
            font-style: italic;
            font-size: 0.9em; /* 缩小占位符字体 */
        }
        .loading-indicator {
            display: none; /* Initially hidden */
            /* display: inline-block; */ /* JS will set this when needed */
            font-style: italic;
            color: #888;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <!-- <h1>多模态 AI 交互示例 (代码块增强)</h1> -->

    <!-- 聊天交互区域 -->
    <div class="section" id="chat-container">
        <h2>与 AI 对话</h2>
        <div id="ai-response">
             <span class="placeholder-text">对话历史将显示在此处...</span>
        </div>

        <!-- 统一输入区域 -->
        <div id="chat-input-container">
            <div id="chat-input" contenteditable="true"></div>
            <div id="input-image-preview">
                 <span class="placeholder-text">粘贴的图片将在此预览...</span>
            </div>
        </div>
         <div id="input-controls">
             <span id="loading" class="loading-indicator">AI 正在回复中...</span>
             <button id="send-button">发送</button>
         </div>
    </div>

    <!-- Marked.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Highlight.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
        /**
         * DOM 元素引用
         */
        const chatInput = document.getElementById('chat-input');
        const imagePreviewArea = document.getElementById('input-image-preview');
        const previewPlaceholder = imagePreviewArea.querySelector('.placeholder-text');
        const sendButton = document.getElementById('send-button');
        const aiResponseArea = document.getElementById('ai-response');
        const aiResponsePlaceholder = aiResponseArea.querySelector('.placeholder-text');
        const loadingIndicator = document.getElementById('loading');

        /**
         * API 配置 (仅供演示 - 请勿在生产环境中使用)
         */
        const apiConfig = {
            key: "gemini", // 警告：API 密钥已暴露，仅供演示！
            baseurl: "https://snemc-geminibalance.hf.space/v1/chat/completions",
            model: "gemini-2.5-pro-exp-03-25", // 重要提示：请确保此模型支持多模态输入！
            system_prompt: "你是一个中文助手，帮助用户回答问题,回答时需要使用中文。如果需要代码，请使用markdown格式输出，并明确指定代码语言类型，例如 ```python ... ```。" // 更新系统提示，鼓励 Markdown 输出并指定语言
        };

        /**
         * 对话历史
         */
        let history_messages = [
            { role: 'system', content: apiConfig.system_prompt }
        ];

        /**
         * 占位符辅助函数
         */
         function handlePreviewPlaceholder() {
            if (imagePreviewArea.children.length <= 1) { // 仅有占位符或为空
                if (!imagePreviewArea.contains(previewPlaceholder)) imagePreviewArea.appendChild(previewPlaceholder);
            } else {
                if (imagePreviewArea.contains(previewPlaceholder)) imagePreviewArea.removeChild(previewPlaceholder);
            }
        }
         function handleAiResponsePlaceholder() {
            // 如果 aiResponseArea 包含除占位符外的任何气泡，则移除占位符
            if (aiResponseArea.querySelector('.message-bubble')) {
                 if (aiResponseArea.contains(aiResponsePlaceholder)) aiResponseArea.removeChild(aiResponsePlaceholder);
            } else {
                 if (!aiResponseArea.contains(aiResponsePlaceholder)) aiResponseArea.appendChild(aiResponsePlaceholder);
            }
        }

        /**
         * 聊天输入区域的粘贴事件监听器
         */
        chatInput.addEventListener('paste', (event) => {
            const items = (event.clipboardData || window.clipboardData).items;
            let foundImage = false;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    foundImage = true;
                    event.preventDefault(); // 阻止图片的默认粘贴行为
                    const blob = items[i].getAsFile();
                    if (blob) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const dataUrl = e.target.result;
                            const mimeType = dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
                            const base64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);

                            // 为 contenteditable 输入区域创建图片
                            const imgInInput = document.createElement('img');
                            imgInInput.src = dataUrl;
                            imgInInput.alt = '粘贴的图片';
                            // 将 base64 数据和 MIME 类型存储在图片元素自身上
                            imgInInput.setAttribute('data-base64', base64Data);
                            imgInInput.setAttribute('data-mime-type', mimeType);
                            // 在 contenteditable div 的光标位置（或末尾）插入图片
                            insertNodeAtCursor(imgInInput);


                            // 为输入下方的预览区域创建图片
                            const imgInPreview = document.createElement('img');
                            imgInPreview.src = dataUrl;
                            imgInPreview.alt = '图片预览';
                            imagePreviewArea.appendChild(imgInPreview);
                            handlePreviewPlaceholder(); // 更新预览区占位符
                        };
                        reader.readAsDataURL(blob);
                    }
                }
            }
            // 如果粘贴的是文本，则允许默认行为（因为我们只阻止了图片的默认行为）
        });

        /**
         * 在 contenteditable 的当前光标位置插入节点的辅助函数
         * @param {Node} node 要插入的节点
         */
        function insertNodeAtCursor(node) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            range.deleteContents(); // 删除选中的内容（如有）

             // 检查光标是否在 chatInput 元素内部
             let container = range.commonAncestorContainer;
             while (container && container !== chatInput) {
                 container = container.parentNode;
             }
             // 如果光标不在 chatInput 内部，则追加到末尾
             if (!container) {
                 chatInput.appendChild(node);
                 // 将光标移动到插入的节点之后
                 range.selectNodeContents(chatInput);
                 range.collapse(false); // 折叠到末尾
                 selection.removeAllRanges();
                 selection.addRange(range);
                 return;
             }

            range.insertNode(node);
            // 将光标移动到插入的节点之后
            range.setStartAfter(node);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }


        /**
         * 发送按钮点击事件监听器
         */
        sendButton.addEventListener('click', async () => {
            const contentParts = extractContentFromInput(chatInput);

            if (contentParts.length === 0 || (contentParts.length === 1 && contentParts[0].type === 'text' && !contentParts[0].text.trim())) {
                 alert('请输入要发送的内容或粘贴图片！');
                 return;
            }


            // 禁用按钮并显示加载指示
            sendButton.disabled = true;
            loadingIndicator.style.display = 'inline-block';
            handleAiResponsePlaceholder(); // 如果存在则移除占位符

            // 构建用户消息
            const userMessage = { role: 'user', content: contentParts };
            history_messages.push(userMessage);

            // 显示用户消息（气泡样式）
            displayUserMessage(userMessage.content);

            // 清空输入区和预览区
            chatInput.innerHTML = '';
            imagePreviewArea.innerHTML = ''; // 清空预览
            handlePreviewPlaceholder(); // 将占位符添加回预览区

            try {
                // 获取 AI 响应
                await fetchAIResponse(history_messages);
            } catch (error) {
                console.error("获取 AI 响应时出错:", error);
                displayMessageInBubble('error', `请求出错: ${error.message}`);
            } finally {
                // 重新启用按钮并隐藏加载指示
                sendButton.disabled = false;
                loadingIndicator.style.display = 'none';
            }
        });

        /**
         * 从 contenteditable div 中提取文本和图片数据
         * @param {Element} element contenteditable div 元素
         * @returns {Array<object>} 内容部分数组（文本或图片对象）
         */
        function extractContentFromInput(element) {
            const parts = [];
            const nodes = element.childNodes;

            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.nodeType === Node.TEXT_NODE) {
                    // 如果是文本节点，添加其内容
                    const text = node.textContent;
                     if (text) { // 避免添加空的文本节点
                         // 如果最后一部分也是文本，则追加到其后
                         if (parts.length > 0 && parts[parts.length - 1].type === 'text') {
                             parts[parts.length - 1].text += text;
                         } else {
                             parts.push({ type: 'text', text: text });
                         }
                     }
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'IMG') {
                    // 如果是我们添加的图片元素，提取其数据
                    const base64Data = node.getAttribute('data-base64');
                    const mimeType = node.getAttribute('data-mime-type');
                    if (base64Data && mimeType) {
                        // 构建 Data URL 字符串
                        const dataUrl = `data:${mimeType};base64,${base64Data}`;
                        // 使用新的格式推送图片数据
                        parts.push({
                            type: 'image_url', // 使用新的类型
                            image_url: {      // 使用新的嵌套对象
                                url: dataUrl      // 使用 Data URL 字符串
                            }
                        });
                    }
                     // 如果需要在文本流中为图片添加占位符文本，或以不同方式处理结构
                     // 为简单起见，此处仅添加图片对象。
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'DIV') {
                    // 处理可能的嵌套 div（例如，来自粘贴的带格式文本）- 递归提取或扁平化
                    // 简单方法：提取 div 的文本内容
                     const text = node.textContent;
                     if (text) {
                         if (parts.length > 0 && parts[parts.length - 1].type === 'text') {
                             parts[parts.length - 1].text += text;
                         } else {
                             parts.push({ type: 'text', text: text });
                         }
                     }
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'BR') {
                     // 处理换行符 - 如果需要，在文本中添加换行符
                     if (parts.length > 0 && parts[parts.length - 1].type === 'text') {
                         parts[parts.length - 1].text += '\n';
                     } else {
                         parts.push({ type: 'text', text: '\n' });
                     }
                }
                // 为简单起见，忽略其他节点类型
            }
             // 修剪文本部分开头/结尾的空白并移除空的文本部分
             return parts.map(part => {
                 if (part.type === 'text') {
                     part.text = part.text.trim(); // 修剪文本块周围的空白
                 }
                 return part;
             }).filter(part => part.type !== 'text' || part.text.length > 0); // 移除空的文本部分
        }


        /**
         * 在 AI 响应区域显示用户消息（气泡样式）
         * @param {Array<object>} contentParts 内容部分数组
         */
        function displayUserMessage(contentParts) {
            handleAiResponsePlaceholder(); // 确保移除占位符

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble user-bubble'; // 应用气泡样式

            const prefix = document.createElement('strong');
            prefix.textContent = 'You: ';
            bubbleDiv.appendChild(prefix);

            // 将内容添加到气泡中
            contentParts.forEach(part => {
                if (part.type === 'text') {
                    // 追加文本节点
                     bubbleDiv.appendChild(document.createTextNode(part.text + ' ')); // 在文本后添加空格
                } else if (part.type === 'image_url') { // 检查新的类型
                    // 追加图片元素
                    const img = document.createElement('img');
                    img.src = part.image_url.url; // 使用 url 字段
                    img.alt = '用户发送的图片';
                    // 应用 user-message-content img 样式（通过父级选择器）
                    bubbleDiv.appendChild(img);
                }
            });

            aiResponseArea.appendChild(bubbleDiv); // 将整个气泡添加到响应区域
            aiResponseArea.scrollTop = aiResponseArea.scrollHeight; // 滚动到底部
        }


        /**
         * 在 AI 响应区域显示错误消息（气泡样式）
         * @param {string} role 'error'
         * @param {string} content 消息内容
         */
        function displayMessageInBubble(role, content) {
             handleAiResponsePlaceholder(); // 确保移除占位符
             const bubbleDiv = document.createElement('div');
             // 可以为错误消息定义单独的气泡样式，或使用助手样式
             bubbleDiv.className = 'message-bubble assistant-bubble error-message'; // 添加 error-message 类

             const prefix = document.createElement('strong');
              prefix.textContent = 'Error: ';
              bubbleDiv.style.color = 'red'; // 错误文本红色
              bubbleDiv.style.borderColor = 'red'; // 错误边框红色 (如果助手气泡有边框)
              bubbleDiv.appendChild(prefix);
              bubbleDiv.appendChild(document.createTextNode(content)); // 追加错误文本

             aiResponseArea.appendChild(bubbleDiv);
             aiResponseArea.scrollTop = aiResponseArea.scrollHeight; // 滚动到底部
             return bubbleDiv;
        }


        /**
         * 获取 AI 响应并处理流式传输 (近似流式 Markdown, 气泡样式, 代码块增强)
         * @param {Array<object>} messages 当前对话历史
         */
        async function fetchAIResponse(messages) {
            const response = await fetch(apiConfig.baseurl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiConfig.key}` },
                body: JSON.stringify({ model: apiConfig.model, messages: messages, stream: true, temperature: 0.7, top_p: 1 })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API 请求失败: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let accumulatedContent = '';
            let assistantBubbleDiv = null; // 整个气泡 Div
            let contentContainer = null;   // 气泡内用于放 Markdown 内容的 Span
            let messageCopyButton = null;  // 整个消息的复制按钮

            // --- 创建助手气泡结构 ---
            assistantBubbleDiv = document.createElement('div');
            assistantBubbleDiv.className = 'message-bubble assistant-bubble';

            const prefix = document.createElement('strong');
            prefix.textContent = 'Assistant: ';
            assistantBubbleDiv.appendChild(prefix);

            contentContainer = document.createElement('span'); // 内容容器
            contentContainer.className = 'assistant-message-content';
            assistantBubbleDiv.appendChild(contentContainer);

            // --- 创建并添加消息复制按钮 ---
            messageCopyButton = document.createElement('button');
            messageCopyButton.className = 'copy-button'; // 使用之前的消息复制按钮样式
            messageCopyButton.textContent = '复制';
            messageCopyButton.title = '复制回答';
            messageCopyButton.disabled = true; // 初始禁用
            assistantBubbleDiv.appendChild(messageCopyButton);

            aiResponseArea.appendChild(assistantBubbleDiv); // 将气泡添加到聊天区域
            handleAiResponsePlaceholder(); // 移除占位符

            // --- 处理流 ---
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break; // 如果流结束，退出循环

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                         if (line.startsWith('data: ')) {
                             const dataString = line.substring(6).trim();
                             if (dataString === '[DONE]') {
                                 // 流结束信号
                                 if (history_messages[history_messages.length - 1]?.content !== accumulatedContent) {
                                     history_messages.push({ role: "assistant", content: accumulatedContent });
                                 }
                                 // 启用消息复制按钮并添加事件监听器
                                 enableCopyButton(messageCopyButton, contentContainer, accumulatedContent);
                                 // 最终处理代码块（如果需要确保最后状态）
                                 processCodeBlocks(contentContainer);
                                 aiResponseArea.scrollTop = aiResponseArea.scrollHeight;
                                 return; // 明确退出函数
                             }
                             try {
                                 const jsonData = JSON.parse(dataString);
                                 if (jsonData.choices && jsonData.choices[0]?.delta?.content) {
                                     const contentChunk = jsonData.choices[0].delta.content;
                                     accumulatedContent += contentChunk;

                                     // --- 近似流式渲染 ---
                                     if (typeof marked !== 'undefined') {
                                         try {
                                             contentContainer.innerHTML = marked.parse(accumulatedContent); // 更新内容容器的 HTML
                                             // --- 处理代码块（高亮、标签、复制按钮）---
                                             processCodeBlocks(contentContainer);

                                         } catch (renderError) {
                                             console.warn("近似流式渲染/处理错误:", renderError);
                                             contentContainer.textContent = accumulatedContent; // 回退纯文本
                                         }
                                     } else {
                                         contentContainer.textContent = accumulatedContent; // 回退纯文本
                                     }
                                     aiResponseArea.scrollTop = aiResponseArea.scrollHeight; // 滚动
                                 }
                             } catch (e) { /* 忽略解析错误 */ }
                         }
                    }
                }
                // --- 流结束后处理 (如果循环正常结束) ---
                 if (history_messages[history_messages.length - 1]?.content !== accumulatedContent) {
                     history_messages.push({ role: "assistant", content: accumulatedContent });
                 }
                 // 启用消息复制按钮并添加事件监听器
                 enableCopyButton(messageCopyButton, contentContainer, accumulatedContent);
                 // 最终处理代码块
                 processCodeBlocks(contentContainer);

            } catch (error) {
                 console.error("读取响应流时出错:", error);
                 displayMessageInBubble('error', `读取响应流时出错: ${error.message}`);
                 throw error;
            } finally {
                reader.releaseLock();
            }
             aiResponseArea.scrollTop = aiResponseArea.scrollHeight;
        }

        /**
         * 处理指定容器内的代码块：高亮、添加语言标签和复制按钮
         * @param {HTMLElement} container 要处理的容器元素
         */
        function processCodeBlocks(container) {
            if (typeof hljs === 'undefined' || !container) return;

            container.querySelectorAll('pre').forEach(preElement => {
                // 防止重复添加按钮和标签
                if (preElement.querySelector('.code-copy-button')) return;

                const codeBlock = preElement.querySelector('code');
                if (!codeBlock) return;

                // 1. 应用高亮
                hljs.highlightElement(codeBlock);

                // 2. 添加语言标签
                let language = '';
                codeBlock.classList.forEach(className => {
                    if (className.startsWith('language-')) {
                        language = className.replace('language-', '');
                        // Handle common aliases or inconsistencies if needed
                        if (language === 'js') language = 'javascript';
                        if (language === 'py') language = 'python';
                        // etc.
                    }
                });
                 // 如果没有检测到语言，尝试从 ```python 格式中提取
                 if (!language && codeBlock.textContent.startsWith('python\n')) language = 'python';
                 if (!language && codeBlock.textContent.startsWith('javascript\n')) language = 'javascript';
                 // ... 其他常见语言

                if (language) {
                    const langLabel = document.createElement('span');
                    langLabel.className = 'code-language-label';
                    langLabel.textContent = language;
                    preElement.prepend(langLabel); // 添加标签
                }

                // 3. 添加代码块复制按钮
                const copyBtn = document.createElement('button');
                copyBtn.className = 'code-copy-button';
                copyBtn.textContent = '复制';
                copyBtn.title = '复制代码';
                preElement.appendChild(copyBtn); // 添加按钮

                copyBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // 防止触发气泡的其他事件（如果未来有）
                    const codeToCopy = codeBlock.textContent;
                    navigator.clipboard.writeText(codeToCopy).then(() => {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '已复制!';
                        copyBtn.disabled = true;
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.disabled = false;
                        }, 2000);
                    }).catch(err => {
                        console.error('无法复制代码: ', err);
                        alert('复制失败!');
                    });
                });
            });
        }


        /**
         * 启用消息复制按钮并添加事件监听器
         * @param {HTMLButtonElement} button 复制按钮元素
         * @param {HTMLElement} contentElement 包含内容（用于回退）的元素
         * @param {string} fullText 要复制的完整文本
         */
        function enableCopyButton(button, contentElement, fullText) {
            if (!button) return;
            button.disabled = false; // 启用按钮
            button.dataset.fullText = fullText; // 存储完整文本

            // 防止重复添加监听器 (如果可能被多次调用)
            if (button.dataset.listenerAttached) return;
            button.dataset.listenerAttached = 'true';

            button.addEventListener('click', () => {
                const textToCopy = button.dataset.fullText || contentElement.textContent;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalText = button.textContent;
                    button.textContent = '已复制!';
                    button.disabled = true;
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                }).catch(err => {
                    console.error('无法复制文本: ', err);
                    alert('复制失败，请手动复制。');
                });
            });
        }


        // 初始占位符设置
        handlePreviewPlaceholder();
        handleAiResponsePlaceholder();

    </script>

</body>
</html>
