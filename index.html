<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多模态 AI 交互示例 (输入增强)</title>
    <!-- Highlight.js CSS (例如：GitHub 主题) -->
    <link rel="stylesheet" href="./css/main.css">
    <link rel="stylesheet" href="./css/github.min.css">
</head>
<body>

    <h1>多模态 AI 交互示例 (输入增强)</h1>

    <!-- 聊天交互区域 -->
    <div class="section" id="chat-container">
        <h2>与 AI 对话</h2>
        <div id="ai-response">
             <span class="placeholder-text">对话历史将显示在此处...</span>
        </div>

        <!-- 统一输入区域 -->
        <div id="chat-input-container">
            <div id="chat-input" contenteditable="true" data-placeholder="在此处输入消息，shift + enter 提交..."></div>
            <div id="input-image-preview">
                 <span class="placeholder-text">粘贴的图片将在此预览...</span>
            </div>
        </div>
         <div id="input-controls">
             <span id="loading" class="loading-indicator" style="display: none;">AI 正在回复中...</span>
             <button id="send-button">发送</button>
         </div>
    </div>

    <script src="./js/marked.min.js" defer></script>
    <script src="./js/highlight.min.js" defer></script>

    <script>
        /**
         * DOM 元素引用
         */
        const chatInput = document.getElementById('chat-input');
        const imagePreviewArea = document.getElementById('input-image-preview');
        const previewPlaceholder = imagePreviewArea.querySelector('.placeholder-text');
        const sendButton = document.getElementById('send-button');
        const aiResponseArea = document.getElementById('ai-response');
        const aiResponsePlaceholder = aiResponseArea.querySelector('.placeholder-text');
        const loadingIndicator = document.getElementById('loading');

        /**
         * API 配置 (仅供演示 - 请勿在生产环境中使用)
         */
        const apiConfig = {
            key: "gemini", // 警告：API 密钥已暴露，仅供演示！
            baseurl: "https://snemc-geminibalance.hf.space/v1/chat/completions",
            model: "gemini-2.5-pro-exp-03-25", // 重要提示：请确保此模型支持多模态输入！
            system_prompt: "你是一个中文助手，帮助用户回答问题,回答时需要使用中文。如果需要代码，请使用markdown格式输出，并明确指定代码语言类型，例如 ```python ... ```。" // 更新系统提示，鼓励 Markdown 输出并指定语言
        };

        /**
         * 对话历史
         */
        let history_messages = [
            { role: 'system', content: apiConfig.system_prompt }
        ];

        /**
         * 占位符辅助函数
         */
         function handlePreviewPlaceholder() {
            if (imagePreviewArea.children.length <= 1) { // 仅有占位符或为空
                if (!imagePreviewArea.contains(previewPlaceholder)) imagePreviewArea.appendChild(previewPlaceholder);
            } else {
                if (imagePreviewArea.contains(previewPlaceholder)) imagePreviewArea.removeChild(previewPlaceholder);
            }
        }
         function handleAiResponsePlaceholder() {
            // 如果 aiResponseArea 包含除占位符外的任何气泡，则移除占位符
            if (aiResponseArea.querySelector('.message-bubble')) {
                 if (aiResponseArea.contains(aiResponsePlaceholder)) aiResponseArea.removeChild(aiResponsePlaceholder);
            } else {
                 if (!aiResponseArea.contains(aiResponsePlaceholder)) aiResponseArea.appendChild(aiResponsePlaceholder);
            }
        }

        /**
         * 聊天输入区域 Placeholder 相关函数
         */
        function isChatInputEmpty(element) {
            // 检查修剪后的文本内容和是否存在图片元素
            const hasImages = element.querySelector('img') !== null;
            const text = element.textContent.trim();
            return text === '' && !hasImages;
        }

        function updateChatInputPlaceholder() {
            if (isChatInputEmpty(chatInput)) {
                chatInput.classList.add('is-placeholder-showing');
            } else {
                chatInput.classList.remove('is-placeholder-showing');
            }
        }

        chatInput.addEventListener('focus', () => {
            chatInput.classList.remove('is-placeholder-showing');
        });
        chatInput.addEventListener('blur', updateChatInputPlaceholder);
        chatInput.addEventListener('input', updateChatInputPlaceholder); // 处理输入/删除/粘贴


        /**
         * 聊天输入区域的粘贴事件监听器
         */
        chatInput.addEventListener('paste', (event) => {
            const items = (event.clipboardData || window.clipboardData).items;
            let foundImage = false;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    foundImage = true;
                    event.preventDefault(); // 阻止图片的默认粘贴行为
                    const blob = items[i].getAsFile();
                    if (blob) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const dataUrl = e.target.result;
                            const mimeType = dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
                            const base64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);

                            // 为 contenteditable 输入区域创建图片
                            const imgInInput = document.createElement('img');
                            imgInInput.src = dataUrl;
                            imgInInput.alt = '粘贴的图片';
                            // 将 base64 数据和 MIME 类型存储在图片元素自身上
                            imgInInput.setAttribute('data-base64', base64Data);
                            imgInInput.setAttribute('data-mime-type', mimeType);
                            // 在 contenteditable div 的光标位置（或末尾）插入图片
                            insertNodeAtCursor(imgInInput);


                            // 为输入下方的预览区域创建图片
                            const imgInPreview = document.createElement('img');
                            imgInPreview.src = dataUrl;
                            imgInPreview.alt = '图片预览';
                            imagePreviewArea.appendChild(imgInPreview);
                            handlePreviewPlaceholder(); // 更新预览区占位符
                            updateChatInputPlaceholder(); // 图片粘贴后也需要更新输入框 placeholder 状态
                        };
                        reader.readAsDataURL(blob);
                    }
                }
            }
            // 如果粘贴的是文本，则允许默认行为（因为我们只阻止了图片的默认行为）
            // 粘贴文本后也需要更新 placeholder 状态，input 事件会处理
        });

        /**
         * 在 contenteditable 的当前光标位置插入节点的辅助函数
         * @param {Node} node 要插入的节点
         */
        function insertNodeAtCursor(node) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            range.deleteContents(); // 删除选中的内容（如有）

             // 检查光标是否在 chatInput 元素内部
             let container = range.commonAncestorContainer;
             while (container && container !== chatInput) {
                 container = container.parentNode;
             }
             // 如果光标不在 chatInput 内部，则追加到末尾
             if (!container) {
                 chatInput.appendChild(node);
                 // 将光标移动到插入的节点之后
                 range.selectNodeContents(chatInput);
                 range.collapse(false); // 折叠到末尾
                 selection.removeAllRanges();
                 selection.addRange(range);
                 return;
             }

            range.insertNode(node);
            // 将光标移动到插入的节点之后
            range.setStartAfter(node);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }


        /**
         * 发送按钮点击事件监听器
         */
        sendButton.addEventListener('click', async () => {
            const contentParts = extractContentFromInput(chatInput);

            if (contentParts.length === 0) { // 简化检查，因为 extractContentFromInput 会过滤空文本
                 alert('请输入要发送的内容或粘贴图片！');
                 return;
            }


            // 禁用按钮并显示加载指示
            sendButton.disabled = true;
            loadingIndicator.style.display = 'inline-block';
            handleAiResponsePlaceholder(); // 如果存在则移除占位符

            // 构建用户消息
            const userMessage = { role: 'user', content: contentParts };
            history_messages.push(userMessage);

            // 显示用户消息（气泡样式）
            displayUserMessage(userMessage.content);

            // 清空输入区和预览区
            chatInput.innerHTML = '';
            imagePreviewArea.innerHTML = ''; // 清空预览
            handlePreviewPlaceholder(); // 将占位符添加回预览区
            updateChatInputPlaceholder(); // 更新输入框 placeholder 状态

            try {
                // 获取 AI 响应
                await fetchAIResponse(history_messages);
            } catch (error) {
                console.error("获取 AI 响应时出错:", error);
                displayMessageInBubble('error', `请求出错: ${error.message}`);
            } finally {
                // 重新启用按钮并隐藏加载指示
                sendButton.disabled = false;
                loadingIndicator.style.display = 'none';
            }
        });

        /**
         * Shift + Enter 提交快捷键监听器
         */
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && event.shiftKey) {
                event.preventDefault(); // 阻止默认换行行为
                if (!sendButton.disabled) { // 仅在按钮可用时触发
                    sendButton.click(); // 模拟点击发送按钮
                }
            }
            // 单独按 Enter 键会执行默认行为（在 contenteditable 中通常是换行或插入 div/br）
        });


        /**
         * 从 contenteditable div 中提取文本和图片数据
         * @param {Element} element contenteditable div 元素
         * @returns {Array<object>} 内容部分数组（文本或图片对象）
         */
        function extractContentFromInput(element) {
            const parts = [];
            const nodes = element.childNodes;

            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.nodeType === Node.TEXT_NODE) {
                    // 如果是文本节点，添加其内容
                    const text = node.textContent;
                     if (text) { // 避免添加空的文本节点
                         // 如果最后一部分也是文本，则追加到其后
                         if (parts.length > 0 && parts[parts.length - 1].type === 'text') {
                             parts[parts.length - 1].text += text;
                         } else {
                             parts.push({ type: 'text', text: text });
                         }
                     }
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'IMG') {
                    // 如果是我们添加的图片元素，提取其数据
                    const base64Data = node.getAttribute('data-base64');
                    const mimeType = node.getAttribute('data-mime-type');
                    if (base64Data && mimeType) {
                        // 构建 Data URL 字符串
                        const dataUrl = `data:${mimeType};base64,${base64Data}`;
                        // 使用新的格式推送图片数据
                        parts.push({
                            type: 'image_url', // 使用新的类型
                            image_url: {      // 使用新的嵌套对象
                                url: dataUrl      // 使用 Data URL 字符串
                            }
                        });
                    }
                     // 如果需要在文本流中为图片添加占位符文本，或以不同方式处理结构
                     // 为简单起见，此处仅添加图片对象。
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'DIV') {
                    // 处理可能的嵌套 div（例如，来自粘贴的带格式文本）- 递归提取或扁平化
                    // 简单方法：提取 div 的文本内容
                     const text = node.textContent;
                     if (text) {
                         if (parts.length > 0 && parts[parts.length - 1].type === 'text') {
                             parts[parts.length - 1].text += text;
                         } else {
                             parts.push({ type: 'text', text: text });
                         }
                     }
                } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'BR') {
                     // 处理换行符 - 如果需要，在文本中添加换行符
                     if (parts.length > 0 && parts[parts.length - 1].type === 'text') {
                         // 确保不在文本末尾添加多余的换行符，除非它是唯一的换行
                         if (parts[parts.length - 1].text !== '\n') {
                              parts[parts.length - 1].text += '\n';
                         }
                     } else {
                         parts.push({ type: 'text', text: '\n' });
                     }
                }
                // 为简单起见，忽略其他节点类型
            }
             // 修剪文本部分开头/结尾的空白并移除空的文本部分
             return parts.map(part => {
                 if (part.type === 'text') {
                     // 移除可能由 contenteditable 插入的多余换行符，但保留用户意图的换行
                     part.text = part.text.replace(/\n{3,}/g, '\n\n').trim(); // 最多保留双换行
                 }
                 return part;
             }).filter(part => part.type !== 'text' || part.text.length > 0); // 移除完全是空白的文本部分
        }


        /**
         * 在 AI 响应区域显示用户消息（气泡样式）
         * @param {Array<object>} contentParts 内容部分数组
         */
        function displayUserMessage(contentParts) {
            handleAiResponsePlaceholder(); // 确保移除占位符

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble user-bubble'; // 应用气泡样式

            const prefix = document.createElement('strong');
            prefix.textContent = 'You: ';
            bubbleDiv.appendChild(prefix);

            // 将内容添加到气泡中
            contentParts.forEach(part => {
                if (part.type === 'text') {
                    // 追加文本节点 (保留换行符)
                     const textNode = document.createTextNode(part.text + ' '); // 在文本后添加空格
                     bubbleDiv.appendChild(textNode);
                     // 如果需要显式处理换行，可以在这里将 \n 替换为 <br>，但 CSS white-space: pre-wrap 应该能处理
                } else if (part.type === 'image_url') { // 检查新的类型
                    // 追加图片元素
                    const img = document.createElement('img');
                    img.src = part.image_url.url; // 使用 url 字段
                    img.alt = '用户发送的图片';
                    // 应用 user-message-content img 样式（通过父级选择器）
                    bubbleDiv.appendChild(img);
                }
            });

            aiResponseArea.appendChild(bubbleDiv); // 将整个气泡添加到响应区域
            aiResponseArea.scrollTop = aiResponseArea.scrollHeight; // 滚动到底部
        }


        /**
         * 在 AI 响应区域显示错误消息（气泡样式）
         * @param {string} role 'error'
         * @param {string} content 消息内容
         */
        function displayMessageInBubble(role, content) {
             handleAiResponsePlaceholder(); // 确保移除占位符
             const bubbleDiv = document.createElement('div');
             // 可以为错误消息定义单独的气泡样式，或使用助手样式
             bubbleDiv.className = 'message-bubble assistant-bubble error-message'; // 添加 error-message 类

             const prefix = document.createElement('strong');
              prefix.textContent = 'Error: ';
              bubbleDiv.style.color = 'red'; // 错误文本红色
              bubbleDiv.style.borderColor = 'red'; // 错误边框红色 (如果助手气泡有边框)
              bubbleDiv.appendChild(prefix);
              bubbleDiv.appendChild(document.createTextNode(content)); // 追加错误文本

             aiResponseArea.appendChild(bubbleDiv);
             aiResponseArea.scrollTop = aiResponseArea.scrollHeight; // 滚动到底部
             return bubbleDiv;
        }


        /**
         * 获取 AI 响应并处理流式传输 (近似流式 Markdown, 气泡样式, 代码块增强)
         * @param {Array<object>} messages 当前对话历史
         */
        async function fetchAIResponse(messages) {
            const response = await fetch(apiConfig.baseurl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiConfig.key}` },
                body: JSON.stringify({ model: apiConfig.model, messages: messages, stream: true, temperature: 0.7, top_p: 1 })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API 请求失败: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            let accumulatedContent = '';
            let assistantBubbleDiv = null; // 整个气泡 Div
            let contentContainer = null;   // 气泡内用于放 Markdown 内容的 Span
            let messageCopyButton = null;  // 整个消息的复制按钮

            // --- 创建助手气泡结构 ---
            assistantBubbleDiv = document.createElement('div');
            assistantBubbleDiv.className = 'message-bubble assistant-bubble';

            const prefix = document.createElement('strong');
            prefix.textContent = 'Assistant: ';
            assistantBubbleDiv.appendChild(prefix);

            contentContainer = document.createElement('span'); // 内容容器
            contentContainer.className = 'assistant-message-content';
            assistantBubbleDiv.appendChild(contentContainer);

            // --- 创建并添加消息复制按钮 ---
            messageCopyButton = document.createElement('button');
            messageCopyButton.className = 'copy-button'; // 使用之前的消息复制按钮样式
            messageCopyButton.textContent = '复制';
            messageCopyButton.title = '复制回答';
            messageCopyButton.disabled = true; // 初始禁用
            assistantBubbleDiv.appendChild(messageCopyButton);

            aiResponseArea.appendChild(assistantBubbleDiv); // 将气泡添加到聊天区域
            handleAiResponsePlaceholder(); // 移除占位符

            // --- 处理流 ---
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break; // 如果流结束，退出循环

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                         if (line.startsWith('data: ')) {
                             const dataString = line.substring(6).trim();
                             if (dataString === '[DONE]') {
                                 // 流结束信号
                                 if (history_messages[history_messages.length - 1]?.content !== accumulatedContent) {
                                     history_messages.push({ role: "assistant", content: accumulatedContent });
                                 }
                                 // 启用消息复制按钮并添加事件监听器
                                 enableCopyButton(messageCopyButton, contentContainer, accumulatedContent);
                                 // 最终处理代码块（确保状态正确）
                                 processCodeBlocks(contentContainer);
                                 aiResponseArea.scrollTop = aiResponseArea.scrollHeight;
                                 return; // 明确退出函数
                             }
                             try {
                                 const jsonData = JSON.parse(dataString);
                                 if (jsonData.choices && jsonData.choices[0]?.delta?.content) {
                                     const contentChunk = jsonData.choices[0].delta.content;
                                     accumulatedContent += contentChunk;

                                     // --- 近似流式渲染 ---
                                     if (typeof marked !== 'undefined') {
                                         try {
                                             contentContainer.innerHTML = marked.parse(accumulatedContent); // 更新内容容器的 HTML
                                             // --- 处理代码块（高亮、标签、复制按钮）---
                                             processCodeBlocks(contentContainer);

                                         } catch (renderError) {
                                             console.warn("近似流式渲染/处理错误:", renderError);
                                             contentContainer.textContent = accumulatedContent; // 回退纯文本
                                         }
                                     } else {
                                         contentContainer.textContent = accumulatedContent; // 回退纯文本
                                     }
                                     aiResponseArea.scrollTop = aiResponseArea.scrollHeight; // 滚动
                                 }
                             } catch (e) { /* 忽略解析错误 */ }
                         }
                    }
                }
                // --- 流结束后处理 (如果循环正常结束) ---
                 if (history_messages[history_messages.length - 1]?.content !== accumulatedContent) {
                     history_messages.push({ role: "assistant", content: accumulatedContent });
                 }
                 // 启用消息复制按钮并添加事件监听器
                 enableCopyButton(messageCopyButton, contentContainer, accumulatedContent);
                 // 最终处理代码块
                 processCodeBlocks(contentContainer);

            } catch (error) {
                 console.error("读取响应流时出错:", error);
                 displayMessageInBubble('error', `读取响应流时出错: ${error.message}`);
                 throw error;
            } finally {
                reader.releaseLock();
            }
             aiResponseArea.scrollTop = aiResponseArea.scrollHeight;
        }

        /**
         * 处理指定容器内的代码块：高亮、添加语言标签和复制按钮
         * @param {HTMLElement} container 要处理的容器元素
         */
        function processCodeBlocks(container) {
            if (typeof hljs === 'undefined' || !container) return;

            container.querySelectorAll('pre').forEach(preElement => {
                // 防止重复添加按钮和标签
                const existingCopyBtn = preElement.querySelector('.code-copy-button');
                const existingLangLabel = preElement.querySelector('.code-language-label');
                if (existingCopyBtn && existingLangLabel) return; // 如果都有了，就跳过

                const codeBlock = preElement.querySelector('code');
                if (!codeBlock) return;

                // 1. 应用高亮 (如果尚未高亮)
                if (!preElement.dataset.highlighted) {
                     hljs.highlightElement(codeBlock);
                     preElement.dataset.highlighted = 'true'; // 标记已高亮
                }


                // 2. 添加语言标签 (如果不存在)
                if (!existingLangLabel) {
                    let language = '';
                    codeBlock.classList.forEach(className => {
                        if (className.startsWith('language-')) {
                            language = className.replace('language-', '');
                            if (language === 'js') language = 'javascript';
                            if (language === 'py') language = 'python';
                        }
                    });
                    if (!language && codeBlock.textContent.startsWith('python\n')) language = 'python';
                    if (!language && codeBlock.textContent.startsWith('javascript\n')) language = 'javascript';

                    if (language) {
                        const langLabel = document.createElement('span');
                        langLabel.className = 'code-language-label';
                        langLabel.textContent = language;
                        preElement.prepend(langLabel); // 添加标签
                    }
                }


                // 3. 添加代码块复制按钮 (如果不存在)
                if (!existingCopyBtn) {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'code-copy-button';
                    copyBtn.textContent = '复制';
                    copyBtn.title = '复制代码';
                    preElement.appendChild(copyBtn); // 添加按钮

                    copyBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const codeToCopy = codeBlock.textContent;
                        navigator.clipboard.writeText(codeToCopy).then(() => {
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = '已复制!';
                            copyBtn.disabled = true;
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                                copyBtn.disabled = false;
                            }, 2000);
                        }).catch(err => {
                            console.error('无法复制代码: ', err);
                            alert('复制失败!');
                        });
                    });
                }
            });
        }


        /**
         * 启用消息复制按钮并添加事件监听器
         * @param {HTMLButtonElement} button 复制按钮元素
         * @param {HTMLElement} contentElement 包含内容（用于回退）的元素
         * @param {string} fullText 要复制的完整文本
         */
        function enableCopyButton(button, contentElement, fullText) {
            if (!button) return;
            button.disabled = false; // 启用按钮
            button.dataset.fullText = fullText; // 存储完整文本

            // 防止重复添加监听器
            if (button.dataset.listenerAttached) return;
            button.dataset.listenerAttached = 'true';

            button.addEventListener('click', () => {
                const textToCopy = button.dataset.fullText || contentElement.textContent;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalText = button.textContent;
                    button.textContent = '已复制!';
                    button.disabled = true;
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                }).catch(err => {
                    console.error('无法复制文本: ', err);
                    alert('复制失败，请手动复制。');
                });
            });
        }


        // 初始占位符设置
        handlePreviewPlaceholder();
        handleAiResponsePlaceholder();
        updateChatInputPlaceholder(); // 初始检查输入框 placeholder

    </script>

</body>
</html>
