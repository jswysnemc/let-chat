# 重构方案：多模态 AI 交互示例模块化

## 1. 重构目标

本次重构旨在解决 `项目评估报告.md` 中指出的关键问题，主要目标包括：

1.  **提升安全性:** 移除硬编码在前端的 API 密钥。
2.  **增强可维护性:** 将庞大的单体 JavaScript 脚本拆分为职责明确、易于理解和修改的模块。
3.  **提高可测试性:** 使核心逻辑（如 API 交互、状态管理）能够进行单元测试。
4.  **改善可扩展性:** 建立清晰的模块化结构，方便未来添加新功能。
5.  **优化代码组织:** 实现关注点分离，降低模块间的耦合度。

## 2. 推荐的新模块划分

建议引入 `src` 目录存放所有 JavaScript 源代码，并采用以下模块结构：

```
.
├── css/
│   ├── main.css
│   └── github.min.css
├── js/                     # (可选，若库通过 npm 管理则可移除)
│   ├── marked.min.js
│   └── highlight.min.js
├── src/
│   ├── main.js             # 应用入口与协调器
│   ├── config.js           # 应用配置 (不含敏感信息)
│   ├── apiClient.js        # API 客户端 (与后端代理交互)
│   ├── ui.js               # UI 操作与 DOM 更新
│   ├── inputController.js  # 用户输入处理与事件监听
│   ├── state.js            # 应用状态管理 (对话历史)
│   ├── markdownRenderer.js # Markdown 解析与代码高亮封装
│   └── utils.js            # 可选：通用工具函数
├── index.html              # 简化后的 HTML 入口
├── 项目介绍.md
├── 项目评估报告.md
└── 重构方案.md             # (本文档)

# --- 概念上的后端代理 (独立部署) ---
# backend-proxy/
#   ├── server.js (或 main.py 等)
#   ├── package.json (或 requirements.txt)
#   └── .env (存放 API 密钥)
```

## 3. 模块核心职责与接口定义 (示例)

*   **`src/config.js`**
    *   **职责:** 存储非敏感的应用配置。
    *   **接口:** `export const API_BASE_URL = '/api/proxy/chat';` (指向后端代理), `export const MODEL_NAME = 'gemini-2.5-pro-exp-03-25';`, `export const SYSTEM_PROMPT = '...';`
*   **`src/state.js`**
    *   **职责:** 管理对话历史记录。
    *   **接口:** `export function getHistory()`, `export function addMessage(role, contentParts)`, `export function getSystemPrompt()`
*   **`src/apiClient.js`**
    *   **职责:** 封装与后端代理的通信，处理请求发送和流式响应。
    *   **接口:** `export async function fetchAIResponse(messages)` (参数为消息数组，返回处理后的流或结果)
*   **`src/ui.js`**
    *   **职责:** 所有直接的 DOM 操作和 UI 状态更新。
    *   **接口:** `export function displayUserMessage(contentParts)`, `export function displayAssistantMessageBubble()`, `export function updateAssistantMessageContent(bubbleElement, htmlContent)`, `export function finalizeAssistantMessage(bubbleElement, fullContent)`, `export function showLoading()`, `export function hideLoading()`, `export function clearInput()`, `export function setupPlaceholders()`, `export function getChatInputElement()`, `export function getResponseAreaElement()`, `export function scrollChatToBottom()`
*   **`src/markdownRenderer.js`**
    *   **职责:** 封装 Markdown 解析和代码高亮逻辑。
    *   **接口:** `export function renderMarkdown(markdownString)` (返回 HTML 字符串), `export function processCodeBlocks(containerElement)` (应用高亮和复制按钮)
*   **`src/inputController.js`**
    *   **职责:** 处理 `contenteditable` 输入框的事件（粘贴、输入、快捷键），提取输入内容。
    *   **接口:** `export function initInputHandling({ inputElement, previewElement, sendButton, onSend })` (传入依赖和发送回调), `export function extractContentFromInput(element)` (可能移至 utils 或内部使用)
*   **`src/main.js`**
    *   **职责:** 应用入口，初始化所有模块，协调模块间的交互流程。
    *   **逻辑:**
        1.  导入所有需要的模块。
        2.  获取 DOM 元素引用 (或通过 `ui.js` 获取)。
        3.  初始化 `ui.js` (如设置占位符)。
        4.  定义 `handleSend` 函数：
            *   从输入框提取内容 (`inputController` 或 `utils`)。
            *   若内容为空则返回。
            *   调用 `ui.js` 显示加载状态，禁用按钮。
            *   获取当前历史 (`state.js`)。
            *   添加用户消息到状态 (`state.js`)。
            *   调用 `ui.js` 显示用户消息。
            *   调用 `ui.js` 清空输入框。
            *   调用 `apiClient.fetchAIResponse` 发起请求。
            *   处理返回的流：创建助手消息气泡 (`ui.js`)，实时更新内容 (`ui.js` + `markdownRenderer.js`)。
            *   完成后：添加助手完整消息到状态 (`state.js`)，最终处理气泡 (`ui.js` + `markdownRenderer.js`)，隐藏加载状态，启用按钮 (`ui.js`)。
        5.  初始化 `inputController.js`，传入 `handleSend` 作为 `onSend` 回调。

## 4. 关键重构步骤

1.  **【安全】建立后端代理 (优先级最高):**
    *   创建一个简单的后端服务（如 Node.js + Express 或 Python + Flask/FastAPI）。
    *   该服务接收前端的 `/api/proxy/chat` 请求。
    *   从安全的环境变量或配置文件中读取真实的 AI API 密钥。
    *   将前端请求体加上密钥，转发给真实的 AI API 端点 (`https://snemc-geminibalance.hf.space/...`)。
    *   将 AI API 的响应（包括流式响应头和内容）透传回前端。
    *   **在前端代码重构前，先将 `index.html` 中的 `apiConfig.baseurl` 指向此代理地址，并移除 `apiConfig.key`。**
2.  **【结构】创建目录和文件:** 建立 `src/` 目录和上述 `.js` 模块文件。
3.  **【工具】引入构建工具 (推荐):**
    *   选择一个现代前端构建工具，如 Vite (推荐，配置简单，开发体验好) 或 Parcel。
    *   按照工具文档进行初始化 (例如 `npm create vite@latest . --template vanilla`)。
    *   这将处理模块导入/导出、开发服务器、生产构建等。
    *   修改 `index.html`，移除所有内联 `<script>` 引用（除了库文件，如果不用 npm 管理的话），只保留一个指向构建工具入口的 `<script type="module" src="/src/main.js"></script>`。
4.  **【迁移】逐步迁移代码:**
    *   **配置:** 将 `apiConfig` 中的非敏感信息移至 `src/config.js`。
    *   **状态:** 将 `history_messages` 及其操作移至 `src/state.js`。
    *   **API 客户端:** 将 `fetchAIResponse` 逻辑移至 `src/apiClient.js`，确保它调用的是代理 URL。
    *   **UI:** 将所有 DOM 操作函数 (创建气泡、更新内容、切换加载状态等) 移至 `src/ui.js`。
    *   **Markdown:** 将 `marked.parse` 和 `processCodeBlocks` 相关逻辑移至 `src/markdownRenderer.js`。
    *   **输入处理:** 将输入框的事件监听器 (`paste`, `keydown`, `input`, `focus`, `blur`) 和 `extractContentFromInput` 移至 `src/inputController.js`。
    *   **协调:** 在 `src/main.js` 中编写初始化逻辑，导入各模块并连接它们（设置事件回调，传递依赖）。
5.  **【清理】移除旧代码:** 确认所有功能正常后，删除 `index.html` 中原有的巨大 `<script>` 块。
6.  **【测试】编写单元测试 (推荐):** 为 `state.js`, `apiClient.js` (可能需要 mock `fetch`), `inputController.js` (提取逻辑) 等编写单元测试。

## 5. 采用的设计模式或原则

*   **模块模式 (Module Pattern):** 利用 ES6 `import`/`export` 实现代码分离和封装。
*   **单例模式 (Singleton Pattern):** `state.js` 可以视为一个简单的单例，维护全局唯一的对话历史。
*   **关注点分离 (Separation of Concerns):** 核心原则，将不同职责的代码分离到不同模块。
*   **单一职责原则 (Single Responsibility Principle):** 每个模块和函数尽量只做好一件事。
*   **依赖注入 (Dependency Injection) (轻量级):** `main.js` 在初始化时将模块间的依赖关系连接起来（例如，将 `handleSend` 函数作为回调注入 `inputController`）。

## 6. 对现有功能可能产生的影响及应对策略

*   **影响:**
    *   重构过程中，功能可能会暂时中断或出现 Bug。
    *   需要额外设置后端代理服务。
    *   如果引入构建工具，需要学习其基本用法。
*   **应对策略:**
    *   **版本控制:** 使用 Git 进行版本控制，频繁提交，方便回滚。
    *   **增量重构:** 按照步骤 4 逐步迁移，每完成一小部分功能迁移后进行测试。
    *   **后端代理先行:** 优先完成并部署后端代理，确保安全问题首先解决。
    *   **测试:** 在重构前后进行充分的手动测试，重构后引入自动化测试。

## 7. 预期收益

*   **安全性显著提升:** API 密钥不再暴露于前端。
*   **可维护性大幅提高:** 代码结构清晰，定位问题和修改逻辑更容易。
*   **可测试性实现:** 核心模块可以进行单元测试，保证代码质量。
*   **可扩展性增强:** 添加新功能或修改现有功能更加方便，对其他模块影响小。
*   **开发效率提升:** 模块化使得代码更易于理解和协作。
*   **代码质量改善:** 遵循更佳的工程实践。